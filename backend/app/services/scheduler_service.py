"""Service for orchestrating the constraint solver to find appointment slots."""
from __future__ import annotations

from collections import defaultdict
from datetime import datetime
import json
import logging
from pathlib import Path
from typing import Any, Iterable

from flask import current_app

from ai.models.constraint_model import (
    AppointmentRequest,
    ClinicSchedule,
    DoctorAvailability,
    RoomAvailability,
    TimeWindow,
    find_feasible_slots,
)
from backend.app.models import Clinic, Constraint, Doctor, Room
from backend.app.services.llm_client import (
    LLMCommunicationError,
    LLMRankingError,
    rank_slots_with_llm,
)

LOGGER = logging.getLogger(__name__)

# This path assumes insights.json is in ai/scripts/ as defined in rag_update.py
# ../ -> app/, ../ -> backend/, ../ -> project root
INSIGHTS_PATH = (
    Path(__file__).resolve().parent.parent.parent / "ai" / "scripts" / "insights.json"
)

PROMPT_TEMPLATE = """You are Interpaws, an AI assistant helping a veterinary clinic schedule
appointments.

Use these insights from past bookings to improve your choices:
{historical_insights}

A pet owner has submitted a request with the following details:
- Clinic: {clinic_name}
- Reason for visit: {reason_for_visit}
- Urgency: {urgency}
- Preferred window: {preferred_start} to {preferred_end}
- Appointment duration: {duration_minutes} minutes

You are given a list of feasible appointment slots generated by a constraint
solver. Each slot has a unique `slot_id` and may list the doctor's specialty.

{slot_listing}

Please choose the best {max_suggestions} slots for the client. Consider:
- **Matching the 'Reason for visit' ({reason_for_visit}) to the doctor's listed 'Specialty'.**
- Matching urgency with the earliest practical time.
- Spacing appointments away from blocked hours.
- Diversity of times to give the client options.

Respond with **only** JSON using this schema:
{{
  "recommendations": [
    {{
      "slot_id": <integer>,
      "score": <float between 0 and 1>,
      "rationale": "<concise, human friendly explanation>"
    }}
  ]
}}

Return between 3 and {max_suggestions} recommendations, ordered from best to
least preferred. Do not include any extra commentary."""


def _load_insights() -> str:
    """Load RAG insights if available, otherwise return a default."""

    if not INSIGHTS_PATH.exists():
        return "No historical insights available yet."
    try:
        with open(INSIGHTS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        insights_list = data.get("insights", [])
        if not insights_list:
            return "No historical insights available yet."
        return "\n".join(f"- {insight}" for insight in insights_list)
    except (IOError, json.JSONDecodeError) as exc:
        LOGGER.warning("Failed to load RAG insights: %s", exc)
        return "Error loading historical insights."


def find_candidate_slots_for_request(
    clinic_id: int, payload: dict[str, Any]
) -> list[dict[str, Any]]:
    """Return serialized appointment slots for the provided clinic and request."""

    clinic = Clinic.query.get(clinic_id)
    if clinic is None:
        raise ValueError(f"Clinic {clinic_id} does not exist.")

    doctors = [doctor for doctor in clinic.doctors if doctor.is_active]
    rooms = [room for room in clinic.rooms if room.is_active]
    constraints = Constraint.query.filter_by(clinic_id=clinic_id).all()

    doctor_specialty_map = {
        doctor.id: doctor.specialty for doctor in doctors if doctor.specialty
    }

    appointment_request = _build_request(payload)
    clinic_schedule = _build_clinic_schedule(payload, constraints)
    doctor_availability = _build_doctor_availability(doctors, constraints)
    room_availability = _build_room_availability(rooms, constraints)

    slots = find_feasible_slots(
        doctor_availability, room_availability, appointment_request, clinic_schedule
    )

    serialized_slots = []
    for index, (doctor_id, room_id, start_time, end_time) in enumerate(
        slots, start=1
    ):
        specialty = doctor_specialty_map.get(doctor_id)
        serialized_slots.append(
            {
                "slot_id": index,
                "doctor_id": doctor_id,
                "room_id": room_id,
                "start_time": start_time.isoformat(),
                "end_time": end_time.isoformat(),
                "doctor_specialty": specialty,
            }
        )

    if not serialized_slots:
        return []

    return _rank_slots(
        clinic=clinic,
        payload=payload,
        serialized_slots=serialized_slots,
        duration_minutes=appointment_request.duration_minutes,
    )


def _rank_slots(
    *,
    clinic: Clinic,
    payload: dict[str, Any],
    serialized_slots: list[dict[str, Any]],
    duration_minutes: int,
) -> list[dict[str, Any]]:
    """Rank slots using the LLM with heuristics as a fallback."""

    max_suggestions = int(current_app.config.get("LLM_MAX_SUGGESTIONS", 5))
    slot_map = {slot["slot_id"]: slot for slot in serialized_slots}
    historical_insights = _load_insights()

    prompt_context = {
        "clinic_name": getattr(clinic, "name", "Interpaws Clinic"),
        "reason_for_visit": payload.get("reason_for_visit", "Not provided"),
        "urgency": payload.get("urgency", "unspecified"),
        "preferred_start": payload.get("preferred_start")
        or payload.get("start", "unspecified"),
        "preferred_end": payload.get("preferred_end")
        or payload.get("end", "unspecified"),
        "duration_minutes": duration_minutes,
        "max_suggestions": max_suggestions,
        "historical_insights": historical_insights,
    }

    try:
        ranked_slots = rank_slots_with_llm(
            slots=serialized_slots,
            prompt_template=PROMPT_TEMPLATE,
            context=prompt_context,
        )
    except (LLMRankingError, LLMCommunicationError) as exc:
        LOGGER.warning("LLM ranking failed; falling back to heuristic ordering: %s", exc)
        return _fallback_ranking(
            slot_map=slot_map,
            max_suggestions=max_suggestions,
            reason=prompt_context["reason_for_visit"],
        )

    ranked_results: list[dict[str, Any]] = []
    for position, recommendation in enumerate(ranked_slots, start=1):
        slot = slot_map.get(recommendation.slot_id)
        if slot is None:
            LOGGER.debug("Recommendation referenced unknown slot_id %s", recommendation.slot_id)
            continue
        ranked_results.append(
            _format_ranked_slot(
                slot=slot,
                rank=position,
                score=recommendation.score,
                rationale=recommendation.rationale,
            )
        )
        if len(ranked_results) >= max_suggestions:
            break

    if not ranked_results:
        LOGGER.warning("LLM returned no usable recommendations; using fallback ordering.")
        return _fallback_ranking(
            slot_map=slot_map,
            max_suggestions=max_suggestions,
            reason=prompt_context["reason_for_visit"],
        )

    return ranked_results


def _format_ranked_slot(
    *,
    slot: dict[str, Any],
    rank: int,
    score: float | None,
    rationale: str,
) -> dict[str, Any]:
    """Produce the API payload for a ranked slot."""

    return {
        "doctor_id": slot["doctor_id"],
        "room_id": slot["room_id"],
        "start_time": slot["start_time"],
        "end_time": slot["end_time"],
        "rank": rank,
        "score": score,
        "rationale": rationale or "Recommended based on availability and urgency.",
    }


def _fallback_ranking(
    *, slot_map: dict[int, dict[str, Any]], max_suggestions: int, reason: str
) -> list[dict[str, Any]]:
    """Fallback ordering when the LLM is unavailable or returns invalid data."""

    slots_sorted = sorted(
        slot_map.values(),
        key=_slot_start_time,
    )

    rationale_suffix = reason if reason and reason != "Not provided" else "the visit"
    results: list[dict[str, Any]] = []
    for idx, slot in enumerate(slots_sorted[:max_suggestions], start=1):
        score = max(1.0 - 0.1 * (idx - 1), 0.0)
        results.append(
            _format_ranked_slot(
                slot=slot,
                rank=idx,
                score=score,
                rationale=(
                    f"One of the earliest available openings for {rationale_suffix}."
                ),
            )
        )

    return results


def _slot_start_time(slot: dict[str, Any]) -> datetime | str:
    """Convert a slot's start time to datetime for reliable ordering."""

    start_text = slot.get("start_time")
    if isinstance(start_text, str):
        try:
            return datetime.fromisoformat(start_text)
        except ValueError:  # pragma: no cover - defensive
            return start_text
    return start_text


def _build_request(payload: dict[str, Any]) -> AppointmentRequest:
    """Translate JSON payload into an AppointmentRequest."""

    try:
        start = _parse_datetime(payload["start"])
        end = _parse_datetime(payload["end"])
    except KeyError as exc:  # pragma: no cover - defensive
        raise ValueError("'start' and 'end' are required fields.") from exc

    duration = int(payload.get("duration_minutes", 0))
    granularity = int(payload.get("granularity_minutes", 15))

    doctor_ids = _parse_int_set(payload.get("doctor_ids"))
    room_ids = _parse_int_set(payload.get("room_ids"))

    required_specialties = _parse_str_set(payload.get("required_specialties"))
    required_equipment = _parse_str_set(payload.get("required_equipment"))
    required_room_type = payload.get("required_room_type")

    return AppointmentRequest(
        start=start,
        end=end,
        duration_minutes=duration,
        granularity_minutes=granularity,
        allowed_doctor_ids=doctor_ids,
        allowed_room_ids=room_ids,
        required_specialties=required_specialties,
        required_room_type=required_room_type,
        required_equipment=required_equipment,
    )


def _build_clinic_schedule(
    payload: dict[str, Any], constraints: Iterable[Constraint]
) -> ClinicSchedule:
    """Create clinic-wide scheduling windows from payload and database records."""

    operating_windows: list[TimeWindow] = []
    for window in payload.get("operating_hours", []) or []:
        try:
            start = _parse_datetime(window["start"])
            end = _parse_datetime(window["end"])
        except (KeyError, ValueError) as exc:  # pragma: no cover - validation
            raise ValueError(
                "Operating hours must include valid 'start' and 'end' timestamps."
            ) from exc
        operating_windows.append(TimeWindow(start=start, end=end))

    clinic_blocks = [
        TimeWindow(start=constraint.start_time, end=constraint.end_time)
        for constraint in constraints
        if constraint.doctor_id is None and constraint.room_id is None
    ]

    return ClinicSchedule(
        operating_windows=operating_windows,
        blocked_windows=clinic_blocks,
    )


def _build_doctor_availability(
    doctors: Iterable[Doctor], constraints: Iterable[Constraint]
) -> list[DoctorAvailability]:
    """Aggregate availability information for doctors."""

    blocks: dict[int, list[TimeWindow]] = defaultdict(list)
    for constraint in constraints:
        if constraint.doctor_id is None:
            continue
        blocks[constraint.doctor_id].append(
            TimeWindow(start=constraint.start_time, end=constraint.end_time)
        )

    availabilities: list[DoctorAvailability] = []
    for doctor in doctors:
        specialties = {doctor.specialty} if doctor.specialty else set()
        availabilities.append(
            DoctorAvailability(
                id=doctor.id,
                specialties=specialties,
                unavailable_windows=blocks.get(doctor.id, ()),
            )
        )
    return availabilities


def _build_room_availability(
    rooms: Iterable[Room], constraints: Iterable[Constraint]
) -> list[RoomAvailability]:
    """Aggregate availability information for rooms."""

    blocks: dict[int, list[TimeWindow]] = defaultdict(list)
    for constraint in constraints:
        if constraint.room_id is None:
            continue
        blocks[constraint.room_id].append(
            TimeWindow(start=constraint.start_time, end=constraint.end_time)
        )

    availabilities: list[RoomAvailability] = []
    for room in rooms:
        availabilities.append(
            RoomAvailability(
                id=room.id,
                room_type=room.room_type,
                unavailable_windows=blocks.get(room.id, ()),
            )
        )
    return availabilities


def _parse_datetime(value: Any) -> datetime:
    """Parse ISO formatted timestamps into datetime objects."""

    if isinstance(value, datetime):
        return value
    if not isinstance(value, str):  # pragma: no cover - defensive
        raise ValueError("Timestamp values must be ISO formatted strings.")
    text = value.strip()
    if not text:
        raise ValueError("Timestamp values cannot be blank.")
    if text.endswith("Z"):
        text = text[:-1] + "+00:00"
    return datetime.fromisoformat(text)


def _parse_int_set(values: Any) -> set[int] | None:
    """Convert a collection of values into a set of ints."""

    if values in (None, ""):
        return None
    result: set[int] = set()
    for item in values:
        if item in (None, ""):
            continue
        result.add(int(item))
    return result or None


def _parse_str_set(values: Any) -> set[str] | None:
    """Convert a collection of values into a normalized set of strings."""

    if values in (None, ""):
        return None
    result: set[str] = set()
    for item in values:
        if not item:
            continue
        result.add(str(item))
    return result or None