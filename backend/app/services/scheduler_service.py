"""Service for orchestrating the constraint solver to find appointment slots."""
from __future__ import annotations

from collections import defaultdict
from datetime import date, datetime, timedelta
import logging
from typing import Any, Iterable

from flask import current_app

from ai.models.constraint_model import (
    AppointmentRequest,
    ClinicSchedule,
    DoctorAvailability,
    RoomAvailability,
    TimeWindow,
    find_feasible_slots,
)
from backend.app.models import (
    Clinic,
    Constraint,
    Doctor,
    DoctorSchedule,
    Room,
    RoomSchedule,
)
from backend.app.services.llm_client import (
    LLMCommunicationError,
    LLMRankingError,
    rank_slots_with_llm,
)

LOGGER = logging.getLogger(__name__)

PROMPT_TEMPLATE = """You are Inter-Paws, an AI assistant helping a veterinary clinic schedule
appointments. A pet owner has submitted a request with the following details:
- Clinic: {clinic_name}
- Reason for visit: {reason_for_visit}
- Urgency: {urgency}
- Preferred window: {preferred_start} to {preferred_end}
- Appointment duration: {duration_minutes} minutes

You are given a list of feasible appointment slots generated by a constraint
solver. Each slot has a unique `slot_id`.

{slot_listing}

Please choose the best {max_suggestions} slots for the client. Consider:
- Matching urgency with the earliest practical time.
- Spacing appointments away from blocked hours.
- Diversity of times to give the client options.

Respond with **only** JSON using this schema:
{{
  "recommendations": [
    {{
      "slot_id": <integer>,
      "score": <float between 0 and 1>,
      "rationale": "<concise, human friendly explanation>"
    }}
  ]
}}

Return between 3 and {max_suggestions} recommendations, ordered from best to
least preferred. Do not include any extra commentary."""


def find_candidate_slots_for_request(
    clinic_id: int, payload: dict[str, Any]
) -> list[dict[str, Any]]:
    """Return serialized appointment slots for the provided clinic and request."""

    clinic = Clinic.query.get(clinic_id)
    if clinic is None:
        raise ValueError(f"Clinic {clinic_id} does not exist.")

    doctors = [doctor for doctor in clinic.doctors if doctor.is_active]
    rooms = [room for room in clinic.rooms if room.is_active]
    constraints = Constraint.query.filter_by(clinic_id=clinic_id).all()
    doctor_schedules = DoctorSchedule.query.filter_by(clinic_id=clinic_id).all()
    room_schedules = RoomSchedule.query.filter_by(clinic_id=clinic_id).all()

    appointment_request = _build_request(payload)
    clinic_schedule = _build_clinic_schedule(payload, constraints)
    doctor_availability = _build_doctor_availability(
        doctors, constraints, doctor_schedules, appointment_request
    )
    room_availability = _build_room_availability(
        rooms, constraints, room_schedules, appointment_request
    )

    slots = find_feasible_slots(
        doctor_availability, room_availability, appointment_request, clinic_schedule
    )

    serialized_slots = [
        {
            "slot_id": index,
            "doctor_id": doctor_id,
            "room_id": room_id,
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat(),
        }
        for index, (doctor_id, room_id, start_time, end_time) in enumerate(
            slots, start=1
        )
    ]

    if not serialized_slots:
        return []

    return _rank_slots(
        clinic=clinic,
        payload=payload,
        serialized_slots=serialized_slots,
        duration_minutes=appointment_request.duration_minutes,
    )


def _rank_slots(
    *,
    clinic: Clinic,
    payload: dict[str, Any],
    serialized_slots: list[dict[str, Any]],
    duration_minutes: int,
) -> list[dict[str, Any]]:
    """Rank slots using the LLM with heuristics as a fallback."""

    max_suggestions = int(current_app.config.get("LLM_MAX_SUGGESTIONS", 5))
    slot_map = {slot["slot_id"]: slot for slot in serialized_slots}
    prompt_context = {
        "clinic_name": getattr(clinic, "name", "Inter-Paws Clinic"),
        "reason_for_visit": payload.get("reason_for_visit", "Not provided"),
        "urgency": payload.get("urgency", "unspecified"),
        "preferred_start": payload.get("preferred_start")
        or payload.get("start", "unspecified"),
        "preferred_end": payload.get("preferred_end")
        or payload.get("end", "unspecified"),
        "duration_minutes": duration_minutes,
        "max_suggestions": max_suggestions,
    }

    try:
        ranked_slots = rank_slots_with_llm(
            slots=serialized_slots,
            prompt_template=PROMPT_TEMPLATE,
            context=prompt_context,
        )
    except (LLMRankingError, LLMCommunicationError) as exc:
        LOGGER.warning("LLM ranking failed; falling back to heuristic ordering: %s", exc)
        return _fallback_ranking(
            slot_map=slot_map,
            max_suggestions=max_suggestions,
            reason=prompt_context["reason_for_visit"],
        )

    ranked_results: list[dict[str, Any]] = []
    for position, recommendation in enumerate(ranked_slots, start=1):
        slot = slot_map.get(recommendation.slot_id)
        if slot is None:
            LOGGER.debug("Recommendation referenced unknown slot_id %s", recommendation.slot_id)
            continue
        ranked_results.append(
            _format_ranked_slot(
                slot=slot,
                rank=position,
                score=recommendation.score,
                rationale=recommendation.rationale,
            )
        )
        if len(ranked_results) >= max_suggestions:
            break

    if not ranked_results:
        LOGGER.warning("LLM returned no usable recommendations; using fallback ordering.")
        return _fallback_ranking(
            slot_map=slot_map,
            max_suggestions=max_suggestions,
            reason=prompt_context["reason_for_visit"],
        )

    return ranked_results


def _format_ranked_slot(
    *,
    slot: dict[str, Any],
    rank: int,
    score: float | None,
    rationale: str,
) -> dict[str, Any]:
    """Produce the API payload for a ranked slot."""

    return {
        "doctor_id": slot["doctor_id"],
        "room_id": slot["room_id"],
        "start_time": slot["start_time"],
        "end_time": slot["end_time"],
        "rank": rank,
        "score": score,
        "rationale": rationale or "Recommended based on availability and urgency.",
    }


def _fallback_ranking(
    *, slot_map: dict[int, dict[str, Any]], max_suggestions: int, reason: str
) -> list[dict[str, Any]]:
    """Fallback ordering when the LLM is unavailable or returns invalid data."""

    slots_sorted = sorted(
        slot_map.values(),
        key=_slot_start_time,
    )

    rationale_suffix = reason if reason and reason != "Not provided" else "the visit"
    results: list[dict[str, Any]] = []
    for idx, slot in enumerate(slots_sorted[:max_suggestions], start=1):
        score = max(1.0 - 0.1 * (idx - 1), 0.0)
        results.append(
            _format_ranked_slot(
                slot=slot,
                rank=idx,
                score=score,
                rationale=(
                    f"One of the earliest available openings for {rationale_suffix}."
                ),
            )
        )

    return results


def _slot_start_time(slot: dict[str, Any]) -> datetime | str:
    """Convert a slot's start time to datetime for reliable ordering."""

    start_text = slot.get("start_time")
    if isinstance(start_text, str):
        try:
            return datetime.fromisoformat(start_text)
        except ValueError:  # pragma: no cover - defensive
            return start_text
    return start_text


def _build_request(payload: dict[str, Any]) -> AppointmentRequest:
    """Translate JSON payload into an AppointmentRequest."""

    try:
        start = _parse_datetime(payload["start"])
        end = _parse_datetime(payload["end"])
    except KeyError as exc:  # pragma: no cover - defensive
        raise ValueError("'start' and 'end' are required fields.") from exc

    duration = int(payload.get("duration_minutes", 0))
    granularity = int(payload.get("granularity_minutes", 15))

    doctor_ids = _parse_int_set(payload.get("doctor_ids"))
    room_ids = _parse_int_set(payload.get("room_ids"))

    required_specialties = _parse_str_set(payload.get("required_specialties"))
    required_equipment = _parse_str_set(payload.get("required_equipment")) or set()
    required_room_type = payload.get("required_room_type")

    return AppointmentRequest(
        start=start,
        end=end,
        duration_minutes=duration,
        granularity_minutes=granularity,
        allowed_doctor_ids=doctor_ids,
        allowed_room_ids=room_ids,
        required_specialties=required_specialties,
        required_room_type=required_room_type,
        required_equipment=required_equipment,
    )


def _build_clinic_schedule(
    payload: dict[str, Any], constraints: Iterable[Constraint]
) -> ClinicSchedule:
    """Create clinic-wide scheduling windows from payload and database records."""

    operating_windows: list[TimeWindow] = []
    for window in payload.get("operating_hours", []) or []:
        try:
            start = _parse_datetime(window["start"])
            end = _parse_datetime(window["end"])
        except (KeyError, ValueError) as exc:  # pragma: no cover - validation
            raise ValueError(
                "Operating hours must include valid 'start' and 'end' timestamps."
            ) from exc
        operating_windows.append(TimeWindow(start=start, end=end))

    clinic_blocks = [
        TimeWindow(start=constraint.start_time, end=constraint.end_time)
        for constraint in constraints
        if constraint.doctor_id is None and constraint.room_id is None
    ]

    return ClinicSchedule(
        operating_windows=operating_windows,
        blocked_windows=clinic_blocks,
    )


def _build_doctor_availability(
    doctors: Iterable[Doctor],
    constraints: Iterable[Constraint],
    schedules: Iterable[DoctorSchedule],
    request: AppointmentRequest,
) -> list[DoctorAvailability]:
    """Aggregate availability information for doctors."""

    constraint_blocks: dict[int, list[TimeWindow]] = defaultdict(list)
    for constraint in constraints:
        if constraint.doctor_id is None:
            continue
        constraint_blocks[constraint.doctor_id].append(
            TimeWindow(start=constraint.start_time, end=constraint.end_time)
        )

    schedule_availability: dict[int, list[TimeWindow]] = defaultdict(list)
    schedule_blocks: dict[int, list[TimeWindow]] = defaultdict(list)
    for schedule in schedules:
        if not schedule.is_active or schedule.weekday is None:
            continue
        windows = _expand_schedule_windows(schedule, request.start, request.end)
        if not windows:
            continue
        if schedule.kind == "availability":
            schedule_availability[schedule.doctor_id].extend(windows)
        else:
            schedule_blocks[schedule.doctor_id].extend(windows)

    availabilities: list[DoctorAvailability] = []
    for doctor in doctors:
        specialties = {doctor.specialty} if doctor.specialty else set()
        unavailable = (
            constraint_blocks.get(doctor.id, []) + schedule_blocks.get(doctor.id, [])
        )
        available = schedule_availability.get(doctor.id, [])
        availabilities.append(
            DoctorAvailability(
                id=doctor.id,
                specialties=specialties,
                available_windows=available,
                unavailable_windows=unavailable,
            )
        )
    return availabilities


def _build_room_availability(
    rooms: Iterable[Room],
    constraints: Iterable[Constraint],
    schedules: Iterable[RoomSchedule],
    request: AppointmentRequest,
) -> list[RoomAvailability]:
    """Aggregate availability information for rooms."""

    constraint_blocks: dict[int, list[TimeWindow]] = defaultdict(list)
    for constraint in constraints:
        if constraint.room_id is None:
            continue
        constraint_blocks[constraint.room_id].append(
            TimeWindow(start=constraint.start_time, end=constraint.end_time)
        )

    schedule_availability: dict[int, list[TimeWindow]] = defaultdict(list)
    schedule_blocks: dict[int, list[TimeWindow]] = defaultdict(list)
    for schedule in schedules:
        if not schedule.is_active or schedule.weekday is None:
            continue
        windows = _expand_schedule_windows(schedule, request.start, request.end)
        if not windows:
            continue
        if schedule.kind == "availability":
            schedule_availability[schedule.room_id].extend(windows)
        else:
            schedule_blocks[schedule.room_id].extend(windows)

    availabilities: list[RoomAvailability] = []
    for room in rooms:
        unavailable = (
            constraint_blocks.get(room.id, []) + schedule_blocks.get(room.id, [])
        )
        available = schedule_availability.get(room.id, [])
        availabilities.append(
            RoomAvailability(
                id=room.id,
                room_type=room.room_type,
                unavailable_windows=unavailable,
                available_windows=available,
            )
        )
    return availabilities


def _expand_schedule_windows(
    schedule: DoctorSchedule | RoomSchedule, start: datetime, end: datetime
) -> list[TimeWindow]:
    """Generate concrete time windows for the given request interval."""

    if schedule.weekday is None:
        return []

    start_boundary = max(start.date(), schedule.start_date or start.date())
    end_boundary_date = schedule.end_date or end.date()
    if end_boundary_date < start_boundary:
        return []

    first_occurrence = _align_to_weekday(start_boundary, schedule.weekday)
    if first_occurrence is None:
        return []

    limit_date = min(end_boundary_date, end.date())
    windows: list[TimeWindow] = []
    current_date = first_occurrence
    while current_date <= limit_date:
        window_start = datetime.combine(current_date, schedule.start_time)
        window_end = datetime.combine(current_date, schedule.end_time)
        if window_end <= window_start:
            break
        if window_end > start and window_start < end:
            windows.append(TimeWindow(start=window_start, end=window_end))
        current_date += timedelta(days=7)

    return windows


def _align_to_weekday(start_date: date, target_weekday: int) -> date | None:
    """Return the first date on or after start_date matching the weekday."""

    if not 0 <= target_weekday <= 6:
        return None
    delta = (target_weekday - start_date.weekday()) % 7
    return start_date + timedelta(days=delta)


def _parse_datetime(value: Any) -> datetime:
    """Parse ISO formatted timestamps into datetime objects."""

    if isinstance(value, datetime):
        return value
    if not isinstance(value, str):  # pragma: no cover - defensive
        raise ValueError("Timestamp values must be ISO formatted strings.")
    text = value.strip()
    if not text:
        raise ValueError("Timestamp values cannot be blank.")
    if text.endswith("Z"):
        text = text[:-1] + "+00:00"
    return datetime.fromisoformat(text)


def _parse_int_set(values: Any) -> set[int] | None:
    """Convert a collection of values into a set of ints."""

    if values in (None, ""):
        return None
    result: set[int] = set()
    for item in values:
        if item in (None, ""):
            continue
        result.add(int(item))
    return result or None


def _parse_str_set(values: Any) -> set[str] | None:
    """Convert a collection of values into a normalized set of strings."""

    if values in (None, ""):
        return None
    result: set[str] = set()
    for item in values:
        if not item:
            continue
        result.add(str(item))
    return result or None
